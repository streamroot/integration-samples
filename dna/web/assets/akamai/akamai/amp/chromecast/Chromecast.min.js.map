{"version":3,"sources":["../../../../src/ChromecastConstants.js","../../../../src/AmpCafSenderCaptioning.js","../../../../src/AmpCafSender.js","../../../../src/Chromecast.js","../../../../src/main.js"],"names":["ChromecastConstants","player","captioning","hidden","plugin","_hidden","bind","_this","_tracks","onEditTracksInfoError","autoSelectTrack","track","this","lang","selectTrackByLanguage","mediaSession","media","tracks","filter","_track","value","trackId","activeTrackIds","onEditTracksInfoSuccess","editTracksInfo","tracksInfoRequest","akamai","EventDispatcher","framework","setLoggerLevel","config","PlayState","READY","onRemotePlayerChange","onMediaSession","addEventListener","cast","SessionEventType","MEDIA_SESSION","createElements","amp","Events","loadPlugins","MEDIA_CHANGE","dispatch","container","document","createElement","appendChild","message","className","element","device","castSession","getCastDevice","friendlyName","innerHTML","getLocalizedString","chromecast","launch","localization","getLanguageString","_this2","getString","key","type","mode","plugins","react","def","AMP","PERSISTENT","feature","classList","logger","log","error","RemotePlayerEventType","event","state","playState","remotePlayer","toLowerCase","DURATION_CHANGE","duration","playerState","customData","temporalType","isLive","ENDED","CAN_PLAY_THROUGH","SEEKED","MUTE_CHANGE","muted","PLAYING","remotePlayerController","removeEventListener","RemotePlayer","ANY_CHANGE","now","Date","DataBinding","evaluateBindings","Utils","override","data","context","currentTime","SEEKING","session","setVolumeLevel","waiting","WAITING","onCastApiAvailable","loadResources","sdk","castContext","CastContext","getInstance","CAST_STATE_CHANGED","onCastStateChanged","setOptions","AutoJoinPolicy","ORIGIN_SCOPED","sessionState","SessionState","busy","getMediaSession","map","source","src","sources","includes","contentId","SESSION_STARTED","ID","AmpCafSender","sender","destroy","GenericMediaMetadata","metadata","chrome","title","Image","poster","subtitle","description","pubDate","toISOString","releaseDate","MediaInfo","mediaInfo","length","index","Track","TrackType","TEXT","forEach","TextTrackType","CAPTIONS","subtype","name","l10n","language","srclang","trackContentId","startTime","catch","Plugin","registerPlugin"],"mappings":"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","file":"akamai/amp/chromecast/Chromecast.min.js","sourcesContent":["export default class ChromecastConstants {\n\n  static get ID() {\n    return \"chromecast\"\n  }\n\n  static get CHANNEL_ID() {\n    return \"urn:x-cast:com.akamai.amp.cast\"\n  }\n\n  static get APPLICATION_ID() {\n    return \"CC1AD845\"\n  }\n\n  static get SUPPORTED_TYPES() {\n    return [\n      akamai.amp.Utils.mimeTypes.m3u8,\n      akamai.amp.Utils.mimeTypes.mp4,\n      akamai.amp.Utils.mimeTypes.mpd,\n      akamai.amp.Utils.mimeTypes.ism,\n      akamai.amp.Utils.mimeTypes.webm,\n      akamai.amp.Utils.mimeTypes.mp3\n    ]\n  }\n}\n","export default class AmpCafSenderCaptioning extends akamai.amp.EventDispatcher {\n\n  constructor(player) {\n    super()\n    this.player = player.player\n    this.plugin = player.plugin\n    this._hidden = this.player.captioning.hidden\n    this._tracks = []\n    this.onEditTracksInfoSuccess = this.onEditTracksInfoSuccess.bind(this)\n    this.onEditTracksInfoError = this.onEditTracksInfoError.bind(this)\n\n    this.autoSelectTrack()\n    this.hidden = this.player.hidden\n  }\n\n  get tracks() {\n    const mediaSession = this.plugin.mediaSession\n    if (mediaSession == null || mediaSession.media == null || mediaSession.media.tracks == null) {\n      return []\n    }\n    return mediaSession.media.tracks.filter((track) => (track.subtype == chrome.cast.media.TextTrackType.CAPTIONS) ? track : null)\n  }\n\n  get track() {\n    return this._track || {}\n  }\n\n  set track(value) {\n    this._track = value\n  }\n\n  get hidden() {\n    return this._hidden\n  }\n\n  set hidden(value) {\n    if (value == this._hidden) {\n      return\n    }\n    this._hidden = value\n\n    const activeTrackIds = (value) ? [] : [this.track.trackId]\n    const tracksInfoRequest = new chrome.cast.media.EditTracksInfoRequest(activeTrackIds)\n    this.plugin.mediaSession.editTracksInfo(tracksInfoRequest, this.onEditTracksInfoSuccess, this.onEditTracksInfoError)\n\n    this.dispatch(\"visibilitychange\", !this._hidden)\n  }\n\n  onEditTracksInfoSuccess(event) {\n\n  }\n\n  onEditTracksInfoError(event) {\n\n  }\n\n  selectTrackByLanguage(lang) {\n    const track = this.tracks.filter((track) => (track.language === lang))[0]\n    if (track != null) {\n      this.track = track\n    }\n    return track\n  }\n\n  changeSettings(obj) {\n\n  }\n\n  autoSelectTrack() {\n    let lang = this.player.language\n    let track = null\n\n    if (lang != null) {\n      lang = lang.split(\"-\").shift()\n      track = this.selectTrackByLanguage(lang)\n    }\n\n    return track\n  }\n}\n","import AmpCafSenderCaptioning from \"./AmpCafSenderCaptioning\"\n\nexport default class AmpCafSender extends akamai.amp.EventDispatcher {\n\n  constructor(plugin) {\n    super()\n    cast.framework.setLoggerLevel(plugin.debug ? cast.framework.LoggerLevel.DEBUG : cast.framework.LoggerLevel.NONE)\n\n    this.player = plugin.player\n    this.config = akamai.amp.Utils.clone(this.player.config)\n    this.plugin = plugin\n    this.state = {\n      playState: akamai.amp.PlayState.READY,\n      waiting: false,\n      seeking: false\n    }\n\n    this.onRemotePlayerChange = this.onRemotePlayerChange.bind(this)\n    this.onMediaSession = this.onMediaSession.bind(this)\n    this.onMediaSession()\n\n    this.plugin.castSession.addEventListener(cast.framework.SessionEventType.MEDIA_SESSION, this.onMediaSession)\n\n    this.createElements()\n    this.loadPlugins()\n      .then(() => {\n        this.dispatch(akamai.amp.Events.READY)\n        this.dispatch(akamai.amp.Events.MEDIA_CHANGE, this.media)\n        this.dispatch(akamai.amp.Events.CAN_PLAY_THROUGH)\n      })\n  }\n\n  createElements() {\n    this.container = document.createElement(\"div\")\n    this.container.className = \"amp-chromecast-sender\"\n    this.player.container.appendChild(this.container)\n\n    this.message = document.createElement(\"div\")\n    this.message.className = \"amp-chromecast-sender-msg\"\n    const element = document.createElement(\"div\")\n    element.className = \"amp-chromecast-sender-text\"\n    element.innerHTML = this.getLocalizedString(\"MSG_CHROMECAST_MESSAGE\", {device: this.plugin.castSession.getCastDevice().friendlyName})\n    this.message.appendChild(element)\n    this.player.container.appendChild(this.message)\n  }\n\n  loadPlugins() {\n    this.chromecast = {\n      available: true,\n      launch: () => this.plugin.launch()\n    }\n\n    if (this.player.captioning != null) {\n      this.captioning = new AmpCafSenderCaptioning(this)\n    }\n\n    this.localization = {\n      getLanguageString: (lang) => this.player.localization.getLanguageString(lang),\n      getString: (key) => this.player.localization.getString(key)\n    }\n\n    const type = this.player.mode\n    const key = \"react\"\n    const def = akamai.amp.AMP.plugins[key][type]\n    const config = this.config.plugins.react\n    config.mode = akamai.amp.react.Mode.PERSISTENT\n\n    if (def == null) {\n      throw new Error(`[AMP] Plugin could not be found: ${key}`)\n    }\n\n    return def(this, config, key)\n      .then((plugin) => {\n        this[key] = plugin\n        if (plugin.feature != null) {\n          this[plugin.feature] = plugin\n        }\n        plugin.container.classList.add(\"amp-remote-playback\")\n        this.logger.log(`[AMP] Plugin registered: ${key}`)\n      })\n      .catch((error) => this.logger.error(error))\n  }\n\n  onRemotePlayerChange(event) {\n    this.logger.log(\"[AMP CHROMECAST EVENT]\", event.field, event.value)\n\n    const type = cast.framework.RemotePlayerEventType\n    const amp = akamai.amp.Events\n    const value = event.value\n\n    switch (event.field) {\n      case \"mediaInfo\":\n        if (this.state.media == null && value != null) {\n          this.state.media = value\n          this.playState = this.remotePlayer.playerState.toLowerCase()\n          this.dispatch(akamai.amp.Events.DURATION_CHANGE, value.duration)\n          if (value.customData && value.customData.media) {\n            const media = value.customData.media\n            this.dispatch(akamai.amp.Events.TEMPORAL_TYPE_CHANGE, media.temporalType)\n            this.dispatch(akamai.amp.Events.IS_LIVE, media.isLive)\n          }\n          this.dispatch(akamai.amp.Events.MEDIA_CHANGE, value)\n        }\n        else if (value == null) {\n          this.state.media = null\n        }\n      break\n\n      case \"isMediaLoaded\":\n        if (value === false) {\n          this.playState = akamai.amp.PlayState.ENDED\n        }\n      break\n\n      case \"currentTime\":\n        if (this.seeking === true) {\n          this.dispatch(akamai.amp.Events.CAN_PLAY_THROUGH)\n          this.dispatch(akamai.amp.Events.SEEKED)\n          this.state.seeking = false\n        }\n\n        if (this.waiting === true) {\n          this.waiting = false\n        }\n\n        this.dispatch(amp.TIME_UPDATE, this.currentTime)\n      break\n\n      case \"duration\":\n        this.dispatch(amp.DURATION_CHANGE, this.duration)\n      break\n\n      case \"volumeLevel\":\n        this.dispatch(amp.VOLUME_CHANGE, this.volume)\n      break\n\n      case \"isMuted\":\n        this.dispatch(amp.VOLUME_CHANGE, (value) ? 0 : this.volume)\n        this.dispatch(amp.MUTE_CHANGE, this.muted)\n      break\n\n      case \"playerState\":\n        let state = null\n\n        switch (value) {\n          case chrome.cast.media.PlayerState.PLAYING:\n            state = akamai.amp.PlayState.PLAYING\n          break\n\n          case chrome.cast.media.PlayerState.PAUSED:\n            state = akamai.amp.PlayState.PAUSED\n          break\n\n          case chrome.cast.media.PlayerState.BUFFERING:\n            this.waiting = true\n          break\n        }\n\n        if (state) {\n          this.playState = state\n        }\n      break\n    }\n    this.dispatch(event)\n  }\n\n  onMediaSession(event) {\n    this.logger.log(\"[AMP CHROMECAST EVENT]\", event)\n\n    if (this.remotePlayerController != null) {\n      this.remotePlayerController.removeEventListener(cast.framework.RemotePlayerEventType.ANY_CHANGE, this.onRemotePlayerChange)\n    }\n    this.remotePlayer = new cast.framework.RemotePlayer()\n    this.remotePlayerController = new cast.framework.RemotePlayerController(this.remotePlayer)\n    this.remotePlayerController.addEventListener(cast.framework.RemotePlayerEventType.ANY_CHANGE, this.onRemotePlayerChange)\n    this.dispatch(event)\n  }\n\n  /**\n   *\n   */\n  evaluateBindings(value, context) {\n    const data = {\n      media: this.media,\n      player: {\n        mode: \"html5\"\n      },\n      now: Date.now()\n    }\n    return akamai.amp.DataBinding.evaluateBindings(value, akamai.amp.Utils.override(data, context))\n  }\n\n  get mediaElement() {\n    return {}\n  }\n\n  get logger() {\n    return this.plugin.logger\n  }\n\n  set currentTime(value) {\n    if (value == this.state.currentTime) {\n      return\n    }\n\n    this.state.seeking = true\n    this.state.currentTime = value\n    this.remotePlayer.currentTime = value\n    if (this.paused === false)\n      this.dispatch(akamai.amp.Events.SEEKING)\n    this.remotePlayerController.seek()\n  }\n\n  get currentTime() {\n    return this.remotePlayer.currentTime\n  }\n\n  get duration() {\n    return this.remotePlayer.duration\n  }\n\n  set autoplay(value) {\n\n  }\n\n  get autoplay() {\n    return true\n  }\n\n  set media(value) {\n    this.plugin.load(this.player.defaultMediaTransform(value))\n  }\n\n  get media() {\n    const session = this.plugin.mediaSession\n    return (session != null && session.media.customData != null) ? session.media.customData.media : this.player.media\n  }\n\n  set volume(value) {\n    this.remotePlayer.volumeLevel = value\n    this.remotePlayerController.setVolumeLevel()\n  }\n\n  get volume() {\n    return this.remotePlayer.volumeLevel\n  }\n\n  set muted(value) {\n    this.remotePlayerController.muteOrUnmute()\n  }\n\n  get muted() {\n    return this.remotePlayer.isMuted\n  }\n\n  set playbackRate(value) {\n\n  }\n\n  get playbackRate() {\n    return 1\n  }\n\n  set waiting(value) {\n    if (value == this.state.waiting) {\n      return\n    }\n\n    this.state.waiting = value\n    if (value) {\n      this.dispatch(akamai.amp.Events.WAITING)\n    }\n  }\n\n  get waiting() {\n    return this.state.waiting\n  }\n\n  get seeking() {\n    return this.state.seeking\n  }\n\n  get paused() {\n    return this.remotePlayer.isPaused\n  }\n\n  get ended() {\n    return false\n  }\n\n  set quality(value) {\n    return\n  }\n\n  get quality() {\n    return 0\n  }\n\n  get qualityMode() {\n    return \"auto\"\n  }\n\n  get qualityLevels() {\n    return []\n  }\n\n  get audioTracks() {\n    return []\n  }\n\n  set playState(value) {\n    const previous = this.state.playState\n    if (value == previous) {\n      return\n    }\n    this.state.playState = value\n    this.dispatch(akamai.amp.Events.PLAY_STATE_CHANGE, {previous, value})\n\n    switch (value) {\n      case akamai.amp.PlayState.PLAYING:\n        this.dispatch(akamai.amp.Events.PLAYING)\n      break\n\n      case akamai.amp.PlayState.PAUSED:\n        this.dispatch(akamai.amp.Events.PAUSE)\n      break\n\n      case akamai.amp.PlayState.ENDED:\n        this.dispatch(akamai.amp.Events.ENDED)\n      break\n    }\n  }\n\n  get playState() {\n    return this.state.playState\n  }\n\n  get viewComponent() {\n    return this.container\n  }\n\n  get settings() {\n    return this.player.settings\n  }\n\n  play() {\n    this.remotePlayerController.playOrPause()\n  }\n\n  pause() {\n    this.remotePlayerController.playOrPause()\n  }\n\n  goLive() {\n\n  }\n\n  getLocalizedString(value, context) {\n    return this.player.getLocalizedString(value, context)\n  }\n\n  destroy() {\n    if (this.remotePlayerController != null) {\n      this.remotePlayerController.removeEventListener(cast.framework.RemotePlayerEventType.ANY_CHANGE, this.onRemotePlayerChange)\n    }\n    this.plugin.castSession.removeEventListener(cast.framework.SessionEventType.MEDIA_SESSION, this.onMediaSession)\n    this.player.container.removeChild(this.container)\n    this.player.container.removeChild(this.message)\n  }\n}\n","import ChromecastConstants from \"./ChromecastConstants\"\nimport AmpCafSender from \"./AmpCafSender\"\n\nexport default class Chromecast extends akamai.amp.Plugin {\n\n  constructor(player, config) {\n    super(player, config)\n\n    this._available = false\n  }\n\n  onready() {\n    this.bindHandlers([\"onCastApiAvailable\", \"onCastStateChanged\", \"onSessionStateChanged\", \"onMediaSession\"])\n    window['__onGCastApiAvailable'] = this.onCastApiAvailable\n\n    this.player.loadResources(this.config.sdk)\n  }\n\n  get available() {\n    return this._available\n  }\n\n  setAvailable(value) {\n    if (value === this._available) {\n      return\n    }\n\n    this._available = value\n    this.player.dispatch(akamai.amp.Events.PLAYBACK_TARGET_AVAILABILITY_CHANGE, {target: ChromecastConstants.ID, available: value})\n  }\n\n  onCastApiAvailable(isAvailable) {\n    if (!isAvailable) {\n      return\n    }\n\n    this.castContext = cast.framework.CastContext.getInstance()\n\n    this.castContext.addEventListener(cast.framework.CastContextEventType.CAST_STATE_CHANGED, this.onCastStateChanged)\n    this.castContext.addEventListener(cast.framework.CastContextEventType.SESSION_STATE_CHANGED, this.onSessionStateChanged)\n    this.castContext.setOptions({\n      receiverApplicationId: this.config.applicationId,\n      autoJoinPolicy: chrome.cast.AutoJoinPolicy.ORIGIN_SCOPED\n    })\n  }\n\n  onCastStateChanged(event) {\n    this.setAvailable((event.castState !== cast.framework.CastState.NO_DEVICES_AVAILABLE))\n    this.dispatch(event)\n  }\n\n  onSessionStateChanged(event) {\n    let mediaSession = null\n\n    switch (event.sessionState) {\n      case cast.framework.SessionState.SESSION_STARTING:\n        this.player.pause()\n        this.player.busy = true\n      break\n\n      case cast.framework.SessionState.SESSION_RESUMED:\n        this.player.busy = true\n        this.castSession = event.session\n        mediaSession = event.session.getMediaSession()\n        if (mediaSession.media && this.player.media) {\n          const sources = (this.player.media.sources || []).map((source) => source.src)\n          sources.push(this.player.media.src)\n          if (sources.includes(mediaSession.media.contentId)) {\n            this.onMediaSession({mediaSession})\n          }\n        }\n      break\n\n      case cast.framework.SessionState.SESSION_STARTED:\n        this.castSession = event.session\n        this.castSession.addEventListener(cast.framework.SessionEventType.MEDIA_SESSION, this.onMediaSession)\n        if (this.castSession.getMediaSession() == null) {\n          this.load(this.player.media, this.player.currentTime)\n        }\n      break\n\n      case cast.framework.SessionState.SESSION_ENDED:\n        mediaSession = event.session.getMediaSession()\n        if (mediaSession != null) {\n          this.player.currentTime = event.session.getMediaSession().currentTime\n        }\n        this.player.playbackTarget = \"amp\"\n      break\n    }\n    this.dispatch(event)\n  }\n\n  onMediaSession(event) {\n    this.mediaSession = event.mediaSession\n    this.player.playbackTarget = ChromecastConstants.ID\n    this.dispatch(event)\n  }\n\n  onplaybacktargetchange(event) {\n    if (event.detail.value === ChromecastConstants.ID) {\n      this.sender = new AmpCafSender(this)\n    }\n    else {\n      if (this.sender != null) {\n        this.sender.destroy()\n      }\n      this.player.busy = false\n    }\n  }\n\n  launch() {\n    this.castContext.requestSession()\n      .catch((error) => {\n        if (error != \"cancel\")\n          this.logger.error(error)\n      })\n  }\n\n  load(media, startTime = 0) {\n\n    if (media == null) {\n      return\n    }\n\n    const source = akamai.amp.Utils.selectSource(media.source, (type) => ChromecastConstants.SUPPORTED_TYPES.includes(type) ? \"maybe\" : \"\")\n\n    if (source == null) {\n      return\n    }\n\n    media.src = source.src\n    media.type = source.type\n\n    const metadata = new chrome.cast.media.GenericMediaMetadata()\n    metadata.title = media.title\n    metadata.subtitle = media.description\n    metadata.image = [new chrome.cast.Image(media.poster)]\n    metadata.releaseDate = (media.pubDate && media.pubDate.toISOString) ? media.pubDate.toISOString() : null\n\n    const mediaInfo = new chrome.cast.media.MediaInfo(source.src, source.type)\n    mediaInfo.duration = media.duration\n    mediaInfo.customData = {media}\n    mediaInfo.metadata = metadata\n\n    if (media.track && media.track.length > 0) {\n      mediaInfo.tracks = []\n      media.track.forEach((value, index) => {\n        const track = new chrome.cast.media.Track(index, chrome.cast.media.TrackType.TEXT)\n        track.subtype = chrome.cast.media.TextTrackType.CAPTIONS\n        track.name = amp.l10n.MSG_CLOSED_CAPTIONING\n        track.language = value.srclang\n        track.customData = value\n        track.trackContentId = value.src\n        track.trackContentType = value.type\n        mediaInfo.tracks.push(track)\n      })\n    }\n\n    const request = new chrome.cast.media.LoadRequest(mediaInfo)\n    request.currentTime = startTime\n\n    this.castSession.loadMedia(request)\n      .catch((error) => this.logger.error(error))\n  }\n}\n","import \"./main.less\"\nimport Chromecast from \"./Chromecast\"\n\nakamai.amp.AMP.registerPlugin(\"chromecast\", akamai.amp.Plugin.createFactory(Chromecast))\n\nexport {Chromecast}\n"]}